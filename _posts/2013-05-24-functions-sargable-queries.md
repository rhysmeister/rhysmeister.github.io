---
layout: post
title: Functions & sargable queries
date: 2013-05-24 11:13:25.000000000 +02:00
type: post
parent_id: '0'
published: true
password: ''
status: publish
categories:
- SQL Server
- T-SQL
tags:
- Execution Plan
- Functions
- sargable
- SQL Server
- TSQL
meta:
  _edit_last: '1'
  tweetbackscheck: '1613453975'
  tweetcount: '0'
  twittercomments: a:0:{}
  shorturls: a:3:{s:9:"permalink";s:66:"http://www.youdidwhatwithtsql.com/functions-sargable-queries/1567/";s:7:"tinyurl";s:26:"http://tinyurl.com/q59e82w";s:4:"isgd";s:19:"http://is.gd/hCSUtz";}
author:
  login: admin
  email: therhysmeister@hotmail.com
  display_name: Rhys
  first_name: ''
  last_name: ''
permalink: "/functions-sargable-queries/1567/"
---
Using&nbsp;functions&nbsp;improperly in your where clauses always prevents index usage right? I've been reviewing some queries generated by [linq](http://msdn.microsoft.com/en-us/library/vstudio/bb397926.aspx "Language-Integrated Query")&nbsp;and I've found out this isn't always the case. A quick demo...

Create a temp tables and insert some data

```
CREATE TABLE #test
(
	id INTEGER NOT NULL PRIMARY KEY CLUSTERED,
	[name] VARCHAR(100) NOT NULL
);

INSERT INTO #test
(
	id,
	[name]
)
VALUES
(
	1, 'Rhys Campbell'
),
(
	2, 'Rhys J Campbell'
),
(
	3, 'R J Campbell'
),
(
	4, 'R Campbell'
),
(
	5, 'Mr J Campbell'
);
```

Create an index on name.

```
CREATE INDEX UIX_name
ON #test
(
	[name]
);
```

You can see this query here uses an index seek despite the use of the the [CONVERT](http://msdn.microsoft.com/en-us/library/ms187928(v=sql.100).aspx "TSQL CONVERT Function") function.

```
SELECT *
FROM #test
WHERE CONVERT(INT, id) = 4;
```

[caption id="attachment\_1568" align="alignnone" width="430"][![SQL Server Execution Plan]({{ site.baseurl }}/assets/2013/05/execution_plan1.png)](http://www.youdidwhatwithtsql.com/wp-content/uploads/2013/05/execution_plan1.png) SQL Server Execution Plan[/caption]

But here you can see the optimiser has been force to perform an index scan to locate our row.

```
SELECT *
FROM #test
WHERE CAST(id AS CHAR(1)) = '4';
```

[caption id="attachment\_1569" align="alignnone" width="450"][![SQL Server Execution Plan]({{ site.baseurl }}/assets/2013/05/execution_plan2.png)](http://www.youdidwhatwithtsql.com/wp-content/uploads/2013/05/execution_plan2.png) SQL Server Execution Plan[/caption]

You can see this query using an index seek.

```
SELECT *
FROM #test
WHERE [name] = 'Rhys Campbell';
```

[caption id="attachment\_1570" align="alignnone" width="460"][![SQL Server Execution Plan]({{ site.baseurl }}/assets/2013/05/execution_plan3.png)](http://www.youdidwhatwithtsql.com/wp-content/uploads/2013/05/execution_plan3.png) SQL Server Execution Plan[/caption]

The next two queries produce the same execution plan. Note the index scan despite the conversion matching the underlying data type in query #1.

```
SELECT *
FROM #test
WHERE CAST([name] AS VARCHAR(100)) = 'Rhys Campbell';

SELECT *
FROM #test
WHERE CONVERT(CHAR(13), [name]) = 'Rhys Campbell';
```

[caption id="attachment\_1571" align="alignnone" width="604"][![SQL Server Execution Plan]({{ site.baseurl }}/assets/2013/05/execution_plan4.png)](http://www.youdidwhatwithtsql.com/wp-content/uploads/2013/05/execution_plan4.png) SQL Server Execution Plan[/caption]

So the Query Optimiser can do some magic with integers but not so much with string data type columns. It seems the function / sargable rule is not absolute and perhaps we will see improvements to this in the future. Even so, I'd like to see this&nbsp;unnecessary&nbsp;conversions removed from queries. At the very least it makes the SQL more readable but it should help give the optimiser a better chance of producing a good plan.

